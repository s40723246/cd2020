var tipuesearch = {"pages": [{'title': 'About', 'text': '此內容管理系統以\xa0 https://github.com/mdecourse/cmsimde \xa0作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n', 'tags': '', 'url': 'About.html'}, {'title': 'weeks', 'text': 'week1~week5 \n week6~week9 \n week10~week14 \n week15~week18 \n 分組網站: https://s40723246.github.io/cd2020-bg1/content/index.html', 'tags': '', 'url': 'weeks.html'}, {'title': 'week1~week5', 'text': 'WEEK1 \n text: \n 1.下載 2019Fall可攜套件.7z \xa0 (編譯\xa0 Solvespace 用)，完成後開啟。 2.登入個人github帳號，創建新的倉儲cd2020。 3.進入要存放的 資料夾 4.輸入 git clone \xa0 https://github.com/s40723246/cd2020 \xa0。 5.輸入git submodule add https://github.com/mdecourse/cmsimde.git 。 6.將up_dir的裡的資料複 製到cd2020 。 7.完成後，python wsgi.py 開始編輯倉儲。 8.編輯完成後， \xa0 git add . \xa0 > \xa0 git commit -m "\xa0 " \xa0 > \xa0 git push。\xa0 \xa0 \n \n WEEK2 \n text: \n 將可攜系統下的python 3.7.3系統更新至python 3.8.2 \n 1.先去GOOGLE SEARCH\xa0 PYTHON \xa0 (點這下載) \n 2.下載 Windows x86-64 executable installer \xa0 (點這下載) \n 3.載完點並 不要勾選pip選項，接著按下next選取放置資料夾 \n 4.在隨身系統下新增放置資料夾cd2020，並在cd2020下新建資料夾data，data<py382< wscite432<portablegit \n 5.下載SciTE系統 \xa0 full 64-bit download ，下載完後解壓縮至data下的wscite432 \n 6.在cd2020下建立新的start.bat及stop.bat \n \n 7.至 SciTE系統更改 start.bat及stop.bat \n \n \n 8. 載入MSYS2\xa0 msys2-x86_64-20190524.exe \xa0至data 9. 載入PortableGit\xa0 64-bit Git for Windows Portable \xa0至 portablegit 10 .裝入 pip ，另存新檔到data 11.測試 將python3.8.2版本，將少的模組下載回來 \n \n 第一組第一次直播會議 \n \n 第一組\xa0  第一次會議PDF內容 \xa0 \xa0 \xa0 (WEEK1 ) \xa0 \n 會議流程: \n 1.成員簽到 \xa0 \n 2.討論日後分工 \xa0 \n 3.有問題的同學提出問題 \xa0 \n 成員名單 \xa0 \n 1. 40723201 \xa0 (簽 ) 已建立完成網站 \xa0 \n 2.40723206 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 3.40723213 (簽) \xa0 已建立完成網站 \xa0 \n 4.40723216 (簽) \xa0 已建立完成網站 \xa0 \n 5.40723223 (簽)\xa0 已建立完成網站 \xa0 \n 6.40723226 (簽) \xa0 已建立完成網站 \xa0 \n 7.40723229 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 8.40723230 (簽) \xa0 已建立完成網站 \xa0 \n 9.40723241 (簽) \xa0 已建立完成網站\xa0 \xa0 \n 10.40723242 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 11.40723246 (group leader) (簽) \xa0 已建立完成網站 \xa0 \n 12.40732319 (簽) \xa0\xa0 \n 日後小組分工 \xa0 \n 1.由(40723201、40723206、40723230、40723241、40723246)， 已經建立好網站及編輯完網站的同學，前去協助還沒完成的同學， 及分配工作 \n 2. 40723213 、 40723242督處尚未完成的同學，互相協助來完成第一周課程 \xa0 \n 3.40723223 、 40723223負責處理小組會議 \xa0 \n 4.40723246 \xa0 負責製作小組會議PDF \n 5.40723241 、 40723216提醒小組問題及完成分組作業 \xa0 \n 組員會議中提醒的事項: \n \xa0 1.網站的格式及編譯 \xa0 \n \xa0 2.其餘的工作分配 \xa0 \n \xa0 3.PDF放倉儲的download及如何放置 \n \n \n week3 \n 上傳製作完成PDF至DOWNLOADS \n', 'tags': '', 'url': 'week1~week5.html'}, {'title': 'week6~week9', 'text': '', 'tags': '', 'url': 'week6~week9.html'}, {'title': 'week10~week14', 'text': '', 'tags': '', 'url': 'week10~week14.html'}, {'title': 'week15~week18', 'text': '', 'tags': '', 'url': 'week15~week18.html'}, {'title': 'assignments', 'text': '', 'tags': '', 'url': 'assignments.html'}, {'title': 'assignment 1', 'text': '', 'tags': '', 'url': 'assignment 1.html'}, {'title': 'portable system', 'text': 'text: \n 將可攜系統下的python 3.7.3系統更新至python 3.8.2 \n 1.先去GOOGLE SEARCH\xa0 PYTHON \xa0 (點這下載) \n 2.下載 Windows x86-64 executable installer \xa0 (點這下載) \n 3.載完點並 不要勾選pip選項，接著按下next選取放置資料夾 \n 4.在隨身系統下新增放置資料夾cd2020，並在cd2020下新建資料夾data，data<py382< wscite432<portablegit \n 5.下載SciTE系統 \xa0 full 64-bit download ，下載完後解壓縮至data下的wscite432 \n 6.在cd2020下建立新的start.bat及stop.bat \n \n 7.至 SciTE系統更改 start.bat及stop.bat \n \n \n 8. 載入MSYS2\xa0 msys2-x86_64-20190524.exe \xa0至data 9. 載入PortableGit\xa0 64-bit Git for Windows Portable \xa0至 portablegit 10 .裝入 pip ，另存新檔到data 11.測試 將python3.8.2版本，將少的模組下載回來 \n \n', 'tags': '', 'url': 'portable system.html'}, {'title': 'random grouping', 'text': 'Random grouping \xa0 \n \xa0 要 進行隨機分組及隨機點名，必須先了解程式裡導入的模組及在模組中所用的 \xa0 語法、迴 圈: request、ast.literal_eval、random、for迴圈 \xa0 \xa0 (1) \xa0 request模組:此模組是為了可以使用 \xa0 Python \xa0 來下載網頁上的資料，是以 \xa0 request模組建立適當的 \xa0 HTTP \xa0 請求，透過 \xa0 HTTP \xa0 請求從網頁伺服器下載 \xa0 指定的資料，分為兩種模式Post、Get。 \xa0 \n \xa0 上述我們將使用 Get 下載回來的資料存入到 a 變數，底下對於 a 變數我們能進行以下操作： \xa0 \n \n url \xa0 : 取得 請求網址 \xa0 \n status_code \xa0 : 伺服器 回應的狀態碼 \xa0 \n text \xa0 : 取得 網頁 HTML 原始碼 \xa0 \n \n 如遇上需要帶上 querystring 參數可以這樣使用： \xa0 參考 文獻: \xa0 https://ithelp.ithome.com.tw/articles/10206215 \xa0 \ufddfHYPERLINK "https://ithelp.ithome.com.tw/articles/10206215" (2) \xa0 ast模組 : \xa0 此 模組是python原始碼到位元組碼的一種中間產物，藉助ast \xa0 模組可以從語法樹的角度分析原始碼結構，其中的語法ast.literal_eval \xa0 是為了能夠安全地評估表達式節點或包含Python文字或容器顯示的字符 \xa0 串。提供的字符串或節點只能由以下Python文字結構組成：字符串、字 \xa0 節、數字、元組、列表、字典、集合、布林值、None。 \xa0 \n Compile函式 \xa0 \n 先簡單瞭解一下compile函式。 \xa0 \n compile( source, filename, mode[, flags[, \xa0 dont_inherit ]])\xa0 \xa0 \n \n source -- \xa0 字串或者AST（Abstract \xa0 Syntax \xa0 Trees）物件。一般可將整個py檔案內容file.read () 傳入 。 \xa0 \n filename -- \xa0 程式碼檔名稱，如果不是從檔案讀取程式碼則傳遞一些可辨認的值 。 \xa0 \n mode -- \xa0 指定編譯程式碼的種類。可以指定為 \xa0 exec, eval, single。 \xa0 \n flags -- \xa0 變數作用域，區域性名稱空間，如果被提供，可以是任何對映物件 。 \xa0 \n \n \n flags和dont_inherit是用來控制編譯原始碼時的標誌 。 \xa0 \n \n \xa0 參考 文獻: https://www.itread01.com/content/1544847254.html \xa0 \xa0 \ufddfHYPERLINK "https://www.itread01.com/content/1544847254.html" (3) \xa0 random模組:此模組用於生成偽隨機數，且有許多種用法，例如:隨機選取 \xa0 choice、隨機選取 \xa0 sample ( 一次選多筆 資料 ) 、 隨機調換順序 \xa0 shuffle (就 \xa0 地調換 順序) 、隨機取得亂數 random (0~1之間的隨機亂數)、隨機取得亂 \xa0 數 uniform \xa0 (可以 指定範圍)。 \xa0 \xa0 參考 文獻: \xa0 https://ithelp.ithome.com.tw/articles/10207483 \xa0 \n (4) \xa0 for迴圈 : \xa0 在處理資料的時候，時常會需要重複執行某些相同的步驟；而迴 \xa0 圈 \xa0 (loop ) 的作用是讓指定的某段敘述在條件符合的情況下一直重覆執行， \xa0 是程式設計中很重要的一種控制結構，且分為兩 類: for、while \xa0 \n \xa0 ○ \xa0 for迴圈基本 語法: for \xa0 變數 \xa0 in \xa0 list、字串、range \xa0 ○ \xa0 while迴圈基本 語法: while \xa0 布林值 \xa0 \xa0 \xa0 \xa0 for迴圈及while迴圈 比較: \xa0 for迴圈比較適用在已知迴圈數的問題，而 \xa0 while迴圈則適用在「無法預知迴圈數」的問題上 。 \xa0 \n 語法 - for \xa0 \n \n A \xa0 、 D \xa0 都省略時， for迴圈 \xa0 跟 \xa0 while迴圈 \xa0 執行起來完全一樣。 \xa0 \n \n for ( [ A.] 一開始先做什麼事 \xa0 ; [B.] 條件式 \xa0 ; [D.] 等C每作完一次，就做什麼事 \xa0 ){\xa0\xa0\xa0 [C.] 當B條件成立時，就重覆做的事 ...} \xa0 \n 通常A、B、D所用到的變數會是一致的。 \xa0 \n \xa0 執行起來流程如下 \xa0 \n 先做 A \xa0 ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ... \xa0 \n ... \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，不成立離開 \xa0 \n \xa0 \n 範例1 - 班級名條 \xa0 \n code \xa0 \n \n # include <iostream> using \xa0 namespace \xa0 std ; int \xa0 main( ){\xa0\xa0\xa0 \xa0 int \xa0 n;\xa0\xa0\xa0 \xa0 int \xa0 i ;\xa0\xa0\xa0 \xa0 cin \xa0 >> n;\xa0\xa0\xa0 \xa0 for ( \xa0 i = 1 \xa0 ; \xa0 i <=n ; \xa0 i =i+ 1 \xa0 )\xa0\xa0\xa0 { \xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 "No." \xa0 << \xa0 i \xa0 << \xa0 endl ;\xa0\xa0\xa0 }\xa0\xa0\xa0 \xa0 return \xa0 0 ;} \xa0 \n for \xa0 vs \xa0 while \xa0 \n \n input \xa0 \n 10 \xa0 \n output \xa0 \n No.1No.2No.3No.4No.5No.6No.7No.8No.9No.10 \xa0 \n \xa0 範例2 - 發射倒數 \xa0 \n \n \n 也可以是做完一次就減少 i \xa0 \n \n # include <iostream> using \xa0 namespace \xa0 std ; int \xa0 main( ){ \xa0\xa0\xa0 \xa0 int \xa0 i ;\xa0\xa0\xa0 \xa0 for ( \xa0 i = 5 \xa0 ; \xa0 i >= 1 \xa0 ; \xa0 i =i- 1 \xa0 )\xa0\xa0\xa0 { \xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 i \xa0 << \xa0 "... " \xa0 << \xa0 endl ;\xa0\xa0\xa0 } \xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 "Go!" \xa0 << \xa0 endl ;\xa0\xa0\xa0 \xa0 return \xa0 0 ;} \xa0 \xa0 參考 文獻: \xa0 https://www.csie.ntu.edu.tw/~b98902112/cpp_and_algo/cpp02/for_loop.html \xa0', 'tags': '', 'url': 'random grouping.html'}, {'title': 'Four wheel car', 'text': 'BubbleRob tutorial :\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0此部分由40723206提供 \n 在此教程中會讓我們設計簡單的BubbleRob機器人並進行一些基礎的模擬操作，而大二上我們其實就有實際的以v-rep操作過這個教程，在這個教程中的說明包括了如何建造模型機器人主體、車輪及後方支撐滑塊，還有如何建造及設置障礙物，以及設定好的距離傳感器後使其去感測並避開我們所設置的障礙物，而最重要的要點是如何去設計指令讓傳動器依照我們所想要的方式去做動，且當距離感測器偵測到障礙物時才能使機器人迅速閃避障礙物，另外還有視覺辨識器，使機器人在移動時，讓我們能夠觀測到機器人行徑方向之路況。 \n \n translation Simulation ~ PDF \n \n \n \n translation\xa0 Simulation dialog ~ PDF \n \n \xa0 \n 在本教程中，我們旨在擴展BubbleRob的功能，以使他/她遵循地面上的規則。確保您已經閱讀並理解了第一個BubbleRob教程。本教程由Eric Rohmer提供。 \n 在CoppeliaSim的安裝文件夾中的tutorials / BubbleRob中加載第一個BubbleRob教程的場景。與本教程相關的場景文件位於tutorials / LineFollowingBubbleRob中。 下圖說明了我們將設計的仿真場景： \n \n 我們首先創建3個視覺傳感器中的第一個，並將其附加到bubbleRob對象。選擇[菜單欄->添加->視覺傳感器->正交類型]。通過雙擊場景層次中新創建的視覺傳感器圖標來編輯其屬性，並更改參數以反映以下對話框： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 \n 視覺傳感器必需面向地面，因此選擇它，然後在“方向”對話框中的“方向”選項上，將“ Alpha-Beta-Gamma”項設置為[180; 0; 0]。 \n 我們有幾種可能性可以讀取視覺傳感器。由於我們的視覺傳感器只有一個像素，並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更複雜的情況，我們可以設置視覺回調函數。現在，複製並貼上視覺傳感器兩次，並將其名稱調整為leftSensor，middleSensor和rightSensor。將bubbleRob設置為其關係（即，將其附加到bubbleRob對象）。現在，您的傳感器在場景層次中應如下所示： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n 讓我們正確放置傳感器。為此使用位置對話框，在位置選項卡上，並設置以下絕對坐標： 左傳感器：[0.2; 0.042; 0.018] 中間傳感器：[0.2; 0; 0.018] 右傳感器：[0.2; -0.042; 0.018] 現在讓我們修改環境。我們可以移去BubbleRob前面的幾個圓柱體。接下來，我們將構建機器人將嘗試遵循的路徑。從現在開始切換到頂視圖：通過頁面選擇器工具欄按鈕選擇頁面4。然後點擊[菜單欄->添加->路徑->圓圈類型]。使用鼠標啟用對象移動。您可以通過兩種方式調整路徑的形狀： 選擇路徑（並且只有路徑）後，按住Ctrl並點擊其控制點之一。然後可以將它們拖動到正確的位置。 選擇路徑後，進入路徑編輯模式。在那裡，您可以靈活地調整各個路徑控制點。 \n 一旦對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改），請選擇它，然後在路徑屬性中取消選中“顯示點的方向”，“顯示路徑線”和“顯示路徑上的當前位置”。然後點擊顯示路徑整形對話框。這將打開路徑整形對話框。點擊啟用路徑變更，將類型設置為水平線段，並將縮放因子設置為4.0。最後將顏色調整為黑色。我們必須對路徑進行最後一個重要的調整：當前，路徑的z位置與地板的z位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在openGl行話中被稱為“ z-fighting”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與z戰鬥有關的問題，只需將路徑對象的位置向上移動0.5毫米即可。 \n 最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。打開附加到bubbleRob的子腳本，並將其替換為以下代碼： \n \n \n \n \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n    leftMotor=sim.getObjectHandle("leftMotor")\n    rightMotor=sim.getObjectHandle("rightMotor")\n    noseSensor=sim.getObjectHandle("sensingNose")\n    minMaxSpeed={50*math.pi/180,300*math.pi/180}\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    floorSensorHandles={-1,-1,-1}\n    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")\n    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")\n    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.reate(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor)\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end\n\n    -- read the line detection sensors:\n    sensorReading={false,false,false}\n    for i=1,3,1 do\n        result,data=sim.readVisionSensor(floorSensorHandles[i])\n        if (result>=0) then\n            sensorReading[i]=(data[11]<0.3) -- data[11] is the average of intensity of the image\n        end\n        print(sensorReading[i])\n    end\n\n    -- compute left and right velocities to follow the detected line:\n    rightV=speed\n    leftV=speed\n    if sensorReading[1] then\n        leftV=0.03*speed\n    end\n    if sensorReading[3] then\n        rightV=0.03*speed\n    end\n    if sensorReading[1] and sensorReading[3] then\n        backUntilTime=sim.getSimulationTime()+2\n    end\n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,leftV)\n        sim.setJointTargetVelocity(rightMotor,rightV)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui) end \n \n \n \n \n 您可以輕鬆地調試以下視覺傳感器的生產線：選擇一個，然後在場景視圖中選擇[右鍵->添加->浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵->視圖- ->將視圖與選定的視覺傳感器關聯]。 \n CoppeliaSim \n 外部控制器教程 在CoppeliaSim中，有幾種方法可以控制機器人或仿真： 最方便的方法是編寫一個子腳本來處理給定機器人或模型的行為。這是最方便的方法，因為子腳本直接附加到場景對象，它們將與相關的場景對像一起復制，它們不需要使用外部工具進行任何編譯，它們可以在線程或非線程模式下運行，它們可以通過自定義Lua函數或Lua擴展庫進行擴展。使用子腳本的另一個主要優點是：與本節中提到的後3種方法（即使用常規API）一樣，沒有通信延遲，並且子腳本是應用程序主線程的一部分（固有的同步操作）。 \n \xa0\xa0\xa0 \xa0 可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使用回調機制，自定義 Lua 函數註冊，當然還可以訪問外部函數庫。插件通常與子腳本結合使用。使用插件的主要優勢還在於，與本節中提到的後 3 種方法（即使用常規 API ）一樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。 \n \xa0\xa0 \xa0 控制機器人或模擬的第三種方法是編寫依賴於遠程 API 的外部客戶端應用程序。如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。遠程 API 有兩個版本：基於 B0 的遠程 API 和舊版遠程 API 。 \n \xa0\xa0\xa0 \xa0 控制機器人或仿真的第五種方法是通過 ROS 節點。 \xa0 ROS 與遠程 API 相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程 API 非常輕巧且快速，但它僅允許與 CoppeliaSim 通信。另一方面， ROS 允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。 \n \xa0\xa0\xa0\xa0 \xa0 控制機器人或模擬的第六種方法是通過 BlueZero （ BØ ）節點。與 ROS 類似， BlueZero 是使多個分佈式進程相互通信的一種便捷方法。 \n \xa0\xa0\xa0\xa0 \xa0 控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與 CoppeliaSim 插件或 CoppeliaSim 腳本進行通信。', 'tags': '', 'url': 'Four wheel car.html'}, {'title': 'assignment 2', 'text': '', 'tags': '', 'url': 'assignment 2.html'}, {'title': 'assignment 3', 'text': '', 'tags': '', 'url': 'assignment 3.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.', 'tags': '', 'url': 'Develop.html'}]};