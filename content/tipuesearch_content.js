var tipuesearch = {"pages": [{'title': 'About', 'text': 'cd2020-bg1分組網站: https://s40723246.github.io/cd2020-bg1/content/index.html \n group members 吳沛汶Repository: \xa0 40723201 \xa0 | Site: \xa0 40723201 王冠驊Repository: \xa0 40723206 \xa0 | Site: \xa0 40723206 \xa0(小組長) 杜玗宸Repository: \xa0 40723213 \xa0 | Site: \xa0 40723213 林子欽Repository: \xa0 40723216 \xa0 | Site: \xa0 40723216 洪維成Repository: \xa0 40723223 \xa0 | Site: \xa0 40723223 高立倫Repository: \xa0 40723226 \xa0 | Site: \xa0 40723226 陳羽泓Repository: \xa0 40723229 \xa0 | Site: \xa0 40723229 \xa0 (小組長) 陳冠樺Repository: \xa0 40723230 \xa0 | Site: \xa0 40723230 葉承叡Repository: \xa0 40723241 \xa0 | Site: \xa0 40723241 趙子得Repository: \xa0 40723242 \xa0 | Site: \xa0 40723242 \xa0(小組長) 鄭竣元Repository: \xa0 40723246 \xa0 | Site: \xa0 40723246 \xa0 (group leader) Repository: \xa0 40732319 \xa0 | Site: \xa0 40732319', 'tags': '', 'url': 'About.html'}, {'title': 'weeks', 'text': 'week1~week5 \n week6~week9 \n week10~week14 \n week15~week18 \n 分組網站: https://s40723246.github.io/cd2020-bg1/content/index.html', 'tags': '', 'url': 'weeks.html'}, {'title': 'week1~week5', 'text': 'WEEK1 \n text: \n 1.下載 2019Fall可攜套件.7z \xa0 (編譯\xa0 Solvespace 用)，完成後開啟。 2.登入個人github帳號，創建新的倉儲cd2020。 3.進入要存放的 資料夾 4.輸入 git clone \xa0 https://github.com/s40723246/cd2020 \xa0。 5.輸入git submodule add https://github.com/mdecourse/cmsimde.git 。 6.將up_dir的裡的資料複 製到cd2020 。 7.完成後，python wsgi.py 開始編輯倉儲。 8.編輯完成後， \xa0 git add . \xa0 > \xa0 git commit -m "\xa0 " \xa0 > \xa0 git push。\xa0 \xa0 \n \n WEEK2 \n text: \n 將可攜系統下的python 3.7.3系統更新至python 3.8.2 \n 1.先去GOOGLE SEARCH\xa0 PYTHON \xa0 (點這下載) \n 2.下載 Windows x86-64 executable installer \xa0 (點這下載) \n 3.載完點並 不要勾選pip選項，接著按下next選取放置資料夾 \n 4.在隨身系統下新增放置資料夾cd2020，並在cd2020下新建資料夾data，data<py382< wscite432<portablegit \n 5.下載SciTE系統 \xa0 full 64-bit download ，下載完後解壓縮至data下的wscite432 \n 6.在cd2020下建立新的start.bat及stop.bat \n \n 7.至 SciTE系統更改 start.bat及stop.bat \n \n \n 8. 載入MSYS2\xa0 msys2-x86_64-20190524.exe \xa0至data 9. 載入PortableGit\xa0 64-bit Git for Windows Portable \xa0至 portablegit 10 .裝入 pip ，另存新檔到data 11.測試 將python3.8.2版本，將少的模組下載回來 \n \n 第一組第一次直播會議 \n \n 第一組\xa0  第一次會議PDF內容 \xa0 \xa0 \xa0 (WEEK1 ) \xa0 \n 會議流程: \n 1.成員簽到 \xa0 \n 2.討論日後分工 \xa0 \n 3.有問題的同學提出問題 \xa0 \n 成員名單 \xa0 \n 1. 40723201 \xa0 (簽 ) 已建立完成網站 \xa0 \n 2.40723206 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 3.40723213 (簽) \xa0 已建立完成網站 \xa0 \n 4.40723216 (簽) \xa0 已建立完成網站 \xa0 \n 5.40723223 (簽)\xa0 已建立完成網站 \xa0 \n 6.40723226 (簽) \xa0 已建立完成網站 \xa0 \n 7.40723229 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 8.40723230 (簽)   無進度 \xa0 \n 9.40723241 (簽) \xa0 已建立完成網站\xa0 \xa0 \n 10.40723242 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 11.40723246 (group leader) (簽) \xa0 已建立完成網站 \xa0 \n 12.40732319 (簽) \xa0 無進度 \n 日後小組分工 \xa0 \n 1.由(40723201、40723206、40723230、40723241、40723246)， 已經建立好網站及編輯完網站的同學，前去協助還沒完成的同學， 及分配工作 \n 2. 40723213 、 40723242督處尚未完成的同學，互相協助來完成第一周課程 \xa0 \n 3.40723223 、 40723223負責處理小組會議 \xa0 \n 4.40723246 \xa0 負責製作小組會議PDF \n 5.40723241 、 40723216提醒小組問題及完成分組作業 \xa0 \n \n 組員會議中提醒的事項: \n \xa0 1.網站的格式及編譯 \xa0 \n \xa0 2.其餘的工作分配 \xa0 \n \xa0 3.PDF放倉儲的download及如何放置 \n \n \n week3 \n 上傳製作完成PDF至DOWNLOADS \n 由成員執行任務並編譯整理製作PDF \n 1. Describe how\xa0to\xa0do an efficient random grouping for this\xa0course or do the roll calling randomly? \n 2. Describe how to prepare a portable Python programming system for Windows 10 64bit system to allow one the maintain \xa0 CMSiMDE \xa0 website, \xa0 Pelican blog \xa0 and \xa0 Reveal.js \xa0 presentation on \xa0 Github ? \n 3. What do you need to know from\xa0 http://www.coppeliarobotics.com/helpFiles/index.html \xa0to implement a four-wheeled robot?\xa0 \n CoppeliaSim User Manual \n translation Simulation ~ PDF \n \n week4 \n 本周報告影片: \n PDF內容描述(有字幕) \n \n \n \xa0 \n', 'tags': '', 'url': 'week1~week5.html'}, {'title': 'week6~week9', 'text': 'week6 \n \n 1.OBS連接，為往後可能線上課程做準備。 \n 2.設定往後影片頭像 \n OBS下載網址: https://obsproject.com/download \n 第一組第二次直播會議 \n \n . 第一組\xa0 第二次會議\xa0\xa0\xa0 \xa0 (WEEK2 ) \xa0 \n \xa0 1.成員簽到等候 \xa0 \n 2.分工作業進度回報及問題討論 \xa0 \n 3.有問題的同學提出問題 \xa0 \n \xa0 成員名單 \xa0 \n 1. 40723201 \xa0 ( 簽 ) \xa0 已建立完成網站 \xa0 \n 2.40723206 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 3.40723213 (簽) \xa0 已建立完成網站 \xa0 \n 4.40723216 (簽) \xa0 已建立完成網站 \xa0 \n 5.40723223 (簽) \xa0 已建立完成網站 \xa0 \n 6.40723226 (簽) \xa0 已建立完成網站 \xa0 \n 7.40723229 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 8.40723230 () \xa0 已建立完成網站 \xa0 \n 9.40723241 (簽) \xa0 已建立完成網站\xa0 \xa0 \n 10.40723242 (簽) \xa0 已建立完成網站 \xa0 小組長 \xa0 \n 11. 40723246 \xa0 (group leader) (簽) \xa0 \xa0 \n 12.40732319 () \xa0 \n \xa0 分工作業進度回報及問題討論 \xa0 \n \xa0 ※作業一 (4 輪 車) \xa0 \n *根據主題 0 和主題 1 的素材，您能否具體描述機械設計團隊，為了完成作業四輪機器人需要做些 什麼? \xa0 \n \xa0 ※作業二 (設計 協同) \xa0 \n * 根據主題 \xa0 Topic 0 們可以創建英語英語詞彙收集服務嗎？ \xa0 \n *根據主題 \xa0 Topic 1 \xa0 我們可以構建在線工具來促進這些過程嗎？ \xa0 \n \xa0 *Topic 0: \xa0 From Digital to Industrial + Engineering Product Design Collaboration ( 從數字到工業+工程產品設計協作 ) \xa0 \n 設計 資料 : DigitalProductCollaboration.pdf 、 IndustrialAndEngineeringProductDesignCollaboration.pdf \xa0 \n Can we create an \xa0 english-english \xa0 vocabulary collection service? \xa0 \n 相關 網站: https://www.autoitscript.com/forum/files/file/419-dictionary_bigdb/ \xa0 \n *Topic 1 : \xa0 Mechanical Design Process ( 機械設計過程 ) \xa0 \n Login to your gm email account and download \xa0 MechanicalDesignProcess.pdf . \xa0 \n 以上由 40723206 分配工作 \xa0 \n \xa0 下列為分工表格 \n \xa0 1.各組員下載OBS，以往後會議討論用 \xa0 \n \n 作業二必須在 4/23 前完成，並上傳 pdf 檔到個人倉儲的 download 上。 不會做的可以問會的同學或在 gitter 上發問。 \n 請依每個人的作業二pdf檔、網站內容，進行互評。 \n \n 本周討論教材 \n Topic 0: From Digital\xa0to Industrial + Engineering Product Design Collaboration \n Login to your gm email account and download \n DigitalProductCollaboration.pdf \n IndustrialAndEngineeringProductDesignCollaboration.pdf \n Can we create an english-english vocabulary collection service? \n https://www.autoitscript.com/forum/files/file/419-dictionary_bigdb/ \n Topic 1: Mechanical Design Process \n Login to your gm email account and download \xa0 MechanicalDesignProcess.pdf . \n (Can we build online tools to facilitate these processes?) \n Successful Design \n Building the\xa0Design \n Structural Considerations \n Materials and\xa0Processes \n Topic 2: Mechatronic System Design \n Login to your gm email account and download \xa0 MSModelingAndTFApproaches.pdf . \n (Can we build online tools to facilitate these processes?) \n Mechatronic Systems \n Mathematical Modeling \n Transfer Function Approaches \n Login to your gm email account and download \xa0 MechatronicDesignCases.pdf . \n DC Motor Velocity and Position Control \n Balancing Robot Control \n Magnetic Levitation System', 'tags': '', 'url': 'week6~week9.html'}, {'title': 'week10~week14', 'text': '', 'tags': '', 'url': 'week10~week14.html'}, {'title': 'week15~week18', 'text': '', 'tags': '', 'url': 'week15~week18.html'}, {'title': 'assignments', 'text': '\n Topic 0: From Digital\xa0to Industrial + Engineering Product Design Collaboration \n Login to your gm email account and download \n DigitalProductCollaboration.pdf \n IndustrialAndEngineeringProductDesignCollaboration.pdf \n Can we create an english-english vocabulary collection service? \n https://www.autoitscript.com/forum/files/file/419-dictionary_bigdb/ \n Topic 1: Mechanical Design Process \n Login to your gm email account and download \xa0 MechanicalDesignProcess.pdf . \n (Can we build online tools to facilitate these processes?) \n Successful Design \n Building the\xa0Design \n Structural Considerations \n Materials and\xa0Processes \n Topic 2: Mechatronic System Design \n Login to your gm email account and download \xa0 MSModelingAndTFApproaches.pdf . \n (Can we build online tools to facilitate these processes?) \n Mechatronic Systems \n Mathematical Modeling \n Transfer Function Approaches \n Login to your gm email account and download \xa0 MechatronicDesignCases.pdf . \n DC Motor Velocity and Position Control \n Balancing Robot Control \n Magnetic Levitation System \n Topic 3: Mechatronic Future and Challenges \n Login to your gm email account and download\xa0 MechaFutureAndChallenges.pdf . \n Mechatronic Futures \n Mechatronics Disrupted \n Challenges in Mechatronics \n Login to your gm email account and download\xa0 MechaEducFutureNeed.pdf . \n Education to meet future need \n Login to your gm email account and \xa0 download all reference files . \n \n \n \n', 'tags': '', 'url': 'assignments.html'}, {'title': 'assignment 1', 'text': '', 'tags': '', 'url': 'assignment 1.html'}, {'title': 'portable system', 'text': 'text: \n 將可攜系統下的python 3.7.3系統更新至python 3.8.2 \n 1.先去GOOGLE SEARCH\xa0 PYTHON \xa0 (點這下載) \n 2.下載 Windows x86-64 executable installer \xa0 (點這下載) \n 3.載完點並 不要勾選pip選項，接著按下next選取放置資料夾 \n 4.在隨身系統下新增放置資料夾cd2020，並在cd2020下新建資料夾data，data<py382< wscite432<portablegit \n 5.下載SciTE系統 \xa0 full 64-bit download ，下載完後解壓縮至data下的wscite432 \n 6.在cd2020下建立新的start.bat及stop.bat \n \n 7.至 SciTE系統更改 start.bat及stop.bat \n \n \n 8. 載入MSYS2\xa0 msys2-x86_64-20190524.exe \xa0至data 9. 載入PortableGit\xa0 64-bit Git for Windows Portable \xa0至 portablegit 10 .裝入 pip ，另存新檔到data 11.測試 將python3.8.2版本，將少的模組下載回來 \n \n', 'tags': '', 'url': 'portable system.html'}, {'title': 'random grouping', 'text': 'Random grouping \xa0 \n \xa0 要 進行隨機分組及隨機點名，必須先了解程式裡導入的模組及在模組中所用的 \xa0 語法、迴 圈: request、ast.literal_eval、random、for迴圈 \xa0 \xa0 (1) \xa0 request模組:此模組是為了可以使用 \xa0 Python \xa0 來下載網頁上的資料，是以 \xa0 request模組建立適當的 \xa0 HTTP \xa0 請求，透過 \xa0 HTTP \xa0 請求從網頁伺服器下載 \xa0 指定的資料，分為兩種模式Post、Get。 \xa0 \n \xa0 上述我們將使用 Get 下載回來的資料存入到 a 變數，底下對於 a 變數我們能進行以下操作： \xa0 \n \n url \xa0 : 取得 請求網址 \xa0 \n status_code \xa0 : 伺服器 回應的狀態碼 \xa0 \n text \xa0 : 取得 網頁 HTML 原始碼 \xa0 \n \n 如遇上需要帶上 querystring 參數可以這樣使用： \xa0 參考 文獻: \xa0 https://ithelp.ithome.com.tw/articles/10206215 \xa0 \ufddfHYPERLINK "https://ithelp.ithome.com.tw/articles/10206215" (2) \xa0 ast模組 : \xa0 此 模組是python原始碼到位元組碼的一種中間產物，藉助ast \xa0 模組可以從語法樹的角度分析原始碼結構，其中的語法ast.literal_eval \xa0 是為了能夠安全地評估表達式節點或包含Python文字或容器顯示的字符 \xa0 串。提供的字符串或節點只能由以下Python文字結構組成：字符串、字 \xa0 節、數字、元組、列表、字典、集合、布林值、None。 \xa0 \n Compile函式 \xa0 \n 先簡單瞭解一下compile函式。 \xa0 \n compile( source, filename, mode[, flags[, \xa0 dont_inherit ]])\xa0 \xa0 \n \n source -- \xa0 字串或者AST（Abstract \xa0 Syntax \xa0 Trees）物件。一般可將整個py檔案內容file.read () 傳入 。 \xa0 \n filename -- \xa0 程式碼檔名稱，如果不是從檔案讀取程式碼則傳遞一些可辨認的值 。 \xa0 \n mode -- \xa0 指定編譯程式碼的種類。可以指定為 \xa0 exec, eval, single。 \xa0 \n flags -- \xa0 變數作用域，區域性名稱空間，如果被提供，可以是任何對映物件 。 \xa0 \n \n \n flags和dont_inherit是用來控制編譯原始碼時的標誌 。 \xa0 \n \n \xa0 參考 文獻: https://www.itread01.com/content/1544847254.html \xa0 \xa0 \ufddfHYPERLINK "https://www.itread01.com/content/1544847254.html" (3) \xa0 random模組:此模組用於生成偽隨機數，且有許多種用法，例如:隨機選取 \xa0 choice、隨機選取 \xa0 sample ( 一次選多筆 資料 ) 、 隨機調換順序 \xa0 shuffle (就 \xa0 地調換 順序) 、隨機取得亂數 random (0~1之間的隨機亂數)、隨機取得亂 \xa0 數 uniform \xa0 (可以 指定範圍)。 \xa0 \xa0 參考 文獻: \xa0 https://ithelp.ithome.com.tw/articles/10207483 \xa0 \n (4) \xa0 for迴圈 : \xa0 在處理資料的時候，時常會需要重複執行某些相同的步驟；而迴 \xa0 圈 \xa0 (loop ) 的作用是讓指定的某段敘述在條件符合的情況下一直重覆執行， \xa0 是程式設計中很重要的一種控制結構，且分為兩 類: for、while \xa0 \n \xa0 ○ \xa0 for迴圈基本 語法: for \xa0 變數 \xa0 in \xa0 list、字串、range \xa0 ○ \xa0 while迴圈基本 語法: while \xa0 布林值 \xa0 \xa0 \xa0 \xa0 for迴圈及while迴圈 比較: \xa0 for迴圈比較適用在已知迴圈數的問題，而 \xa0 while迴圈則適用在「無法預知迴圈數」的問題上 。 \xa0 \n 語法 - for \xa0 \n \n A \xa0 、 D \xa0 都省略時， for迴圈 \xa0 跟 \xa0 while迴圈 \xa0 執行起來完全一樣。 \xa0 \n \n for ( [ A.] 一開始先做什麼事 \xa0 ; [B.] 條件式 \xa0 ; [D.] 等C每作完一次，就做什麼事 \xa0 ){\xa0\xa0\xa0 [C.] 當B條件成立時，就重覆做的事 ...} \xa0 \n 通常A、B、D所用到的變數會是一致的。 \xa0 \n \xa0 執行起來流程如下 \xa0 \n 先做 A \xa0 ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ... \xa0 \n ... \xa0 \n ==> \xa0 檢查 B 條件，成立就做 C ，接著做 D \xa0 \n ==> \xa0 檢查 B 條件，不成立離開 \xa0 \n \xa0 \n 範例1 - 班級名條 \xa0 \n code \xa0 \n \n # include <iostream> using \xa0 namespace \xa0 std ; int \xa0 main( ){\xa0\xa0\xa0 \xa0 int \xa0 n;\xa0\xa0\xa0 \xa0 int \xa0 i ;\xa0\xa0\xa0 \xa0 cin \xa0 >> n;\xa0\xa0\xa0 \xa0 for ( \xa0 i = 1 \xa0 ; \xa0 i <=n ; \xa0 i =i+ 1 \xa0 )\xa0\xa0\xa0 { \xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 "No." \xa0 << \xa0 i \xa0 << \xa0 endl ;\xa0\xa0\xa0 }\xa0\xa0\xa0 \xa0 return \xa0 0 ;} \xa0 \n for \xa0 vs \xa0 while \xa0 \n \n input \xa0 \n 10 \xa0 \n output \xa0 \n No.1No.2No.3No.4No.5No.6No.7No.8No.9No.10 \xa0 \n \xa0 範例2 - 發射倒數 \xa0 \n \n \n 也可以是做完一次就減少 i \xa0 \n \n # include <iostream> using \xa0 namespace \xa0 std ; int \xa0 main( ){ \xa0\xa0\xa0 \xa0 int \xa0 i ;\xa0\xa0\xa0 \xa0 for ( \xa0 i = 5 \xa0 ; \xa0 i >= 1 \xa0 ; \xa0 i =i- 1 \xa0 )\xa0\xa0\xa0 { \xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 i \xa0 << \xa0 "... " \xa0 << \xa0 endl ;\xa0\xa0\xa0 } \xa0\xa0\xa0 \xa0 cout \xa0 << \xa0 "Go!" \xa0 << \xa0 endl ;\xa0\xa0\xa0 \xa0 return \xa0 0 ;} \xa0 \xa0 參考 文獻: \xa0 https://www.csie.ntu.edu.tw/~b98902112/cpp_and_algo/cpp02/for_loop.html \xa0', 'tags': '', 'url': 'random grouping.html'}, {'title': 'Four wheel car', 'text': 'BubbleRob tutorial :\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0此部分由40723206提供 \n 在此教程中會讓我們設計簡單的BubbleRob機器人並進行一些基礎的模擬操作，而大二上我們其實就有實際的以v-rep操作過這個教程，在這個教程中的說明包括了如何建造模型機器人主體、車輪及後方支撐滑塊，還有如何建造及設置障礙物，以及設定好的距離傳感器後使其去感測並避開我們所設置的障礙物，而最重要的要點是如何去設計指令讓傳動器依照我們所想要的方式去做動，且當距離感測器偵測到障礙物時才能使機器人迅速閃避障礙物，另外還有視覺辨識器，使機器人在移動時，讓我們能夠觀測到機器人行徑方向之路況。 \n \n translation Simulation ~ PDF \n \n \n \n translation\xa0 Simulation dialog ~ PDF \n \n \xa0 \n 在本教程中，我們旨在擴展BubbleRob的功能，以使他/她遵循地面上的規則。確保您已經閱讀並理解了第一個BubbleRob教程。本教程由Eric Rohmer提供。 \n 在CoppeliaSim的安裝文件夾中的tutorials / BubbleRob中加載第一個BubbleRob教程的場景。與本教程相關的場景文件位於tutorials / LineFollowingBubbleRob中。 下圖說明了我們將設計的仿真場景： \n \n 我們首先創建3個視覺傳感器中的第一個，並將其附加到bubbleRob對象。選擇[菜單欄->添加->視覺傳感器->正交類型]。通過雙擊場景層次中新創建的視覺傳感器圖標來編輯其屬性，並更改參數以反映以下對話框： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 \n 視覺傳感器必需面向地面，因此選擇它，然後在“方向”對話框中的“方向”選項上，將“ Alpha-Beta-Gamma”項設置為[180; 0; 0]。 \n 我們有幾種可能性可以讀取視覺傳感器。由於我們的視覺傳感器只有一個像素，並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更複雜的情況，我們可以設置視覺回調函數。現在，複製並貼上視覺傳感器兩次，並將其名稱調整為leftSensor，middleSensor和rightSensor。將bubbleRob設置為其關係（即，將其附加到bubbleRob對象）。現在，您的傳感器在場景層次中應如下所示： \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n 讓我們正確放置傳感器。為此使用位置對話框，在位置選項卡上，並設置以下絕對坐標： 左傳感器：[0.2; 0.042; 0.018] 中間傳感器：[0.2; 0; 0.018] 右傳感器：[0.2; -0.042; 0.018] 現在讓我們修改環境。我們可以移去BubbleRob前面的幾個圓柱體。接下來，我們將構建機器人將嘗試遵循的路徑。從現在開始切換到頂視圖：通過頁面選擇器工具欄按鈕選擇頁面4。然後點擊[菜單欄->添加->路徑->圓圈類型]。使用鼠標啟用對象移動。您可以通過兩種方式調整路徑的形狀： 選擇路徑（並且只有路徑）後，按住Ctrl並點擊其控制點之一。然後可以將它們拖動到正確的位置。 選擇路徑後，進入路徑編輯模式。在那裡，您可以靈活地調整各個路徑控制點。 \n 一旦對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改），請選擇它，然後在路徑屬性中取消選中“顯示點的方向”，“顯示路徑線”和“顯示路徑上的當前位置”。然後點擊顯示路徑整形對話框。這將打開路徑整形對話框。點擊啟用路徑變更，將類型設置為水平線段，並將縮放因子設置為4.0。最後將顏色調整為黑色。我們必須對路徑進行最後一個重要的調整：當前，路徑的z位置與地板的z位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在openGl行話中被稱為“ z-fighting”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與z戰鬥有關的問題，只需將路徑對象的位置向上移動0.5毫米即可。 \n 最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。打開附加到bubbleRob的子腳本，並將其替換為以下代碼： \n \n \n \n \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n    leftMotor=sim.getObjectHandle("leftMotor")\n    rightMotor=sim.getObjectHandle("rightMotor")\n    noseSensor=sim.getObjectHandle("sensingNose")\n    minMaxSpeed={50*math.pi/180,300*math.pi/180}\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    floorSensorHandles={-1,-1,-1}\n    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")\n    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")\n    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.reate(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor)\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end\n\n    -- read the line detection sensors:\n    sensorReading={false,false,false}\n    for i=1,3,1 do\n        result,data=sim.readVisionSensor(floorSensorHandles[i])\n        if (result>=0) then\n            sensorReading[i]=(data[11]<0.3) -- data[11] is the average of intensity of the image\n        end\n        print(sensorReading[i])\n    end\n\n    -- compute left and right velocities to follow the detected line:\n    rightV=speed\n    leftV=speed\n    if sensorReading[1] then\n        leftV=0.03*speed\n    end\n    if sensorReading[3] then\n        rightV=0.03*speed\n    end\n    if sensorReading[1] and sensorReading[3] then\n        backUntilTime=sim.getSimulationTime()+2\n    end\n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,leftV)\n        sim.setJointTargetVelocity(rightMotor,rightV)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui) end \n \n \n \n \n 您可以輕鬆地調試以下視覺傳感器的生產線：選擇一個，然後在場景視圖中選擇[右鍵->添加->浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵->視圖- ->將視圖與選定的視覺傳感器關聯]。 \n CoppeliaSim \n 外部控制器教程 在CoppeliaSim中，有幾種方法可以控制機器人或仿真： 最方便的方法是編寫一個子腳本來處理給定機器人或模型的行為。這是最方便的方法，因為子腳本直接附加到場景對象，它們將與相關的場景對像一起復制，它們不需要使用外部工具進行任何編譯，它們可以在線程或非線程模式下運行，它們可以通過自定義Lua函數或Lua擴展庫進行擴展。使用子腳本的另一個主要優點是：與本節中提到的後3種方法（即使用常規API）一樣，沒有通信延遲，並且子腳本是應用程序主線程的一部分（固有的同步操作）。 \n \xa0\xa0\xa0 \xa0 可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使用回調機制，自定義 Lua 函數註冊，當然還可以訪問外部函數庫。插件通常與子腳本結合使用。使用插件的主要優勢還在於，與本節中提到的後 3 種方法（即使用常規 API ）一樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。 \n \xa0\xa0 \xa0 控制機器人或模擬的第三種方法是編寫依賴於遠程 API 的外部客戶端應用程序。如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。遠程 API 有兩個版本：基於 B0 的遠程 API 和舊版遠程 API 。 \n \xa0\xa0\xa0 \xa0 控制機器人或仿真的第五種方法是通過 ROS 節點。 \xa0 ROS 與遠程 API 相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程 API 非常輕巧且快速，但它僅允許與 CoppeliaSim 通信。另一方面， ROS 允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。 \n \xa0\xa0\xa0\xa0 \xa0 控制機器人或模擬的第六種方法是通過 BlueZero （ BØ ）節點。與 ROS 類似， BlueZero 是使多個分佈式進程相互通信的一種便捷方法。 \n \xa0\xa0\xa0\xa0 \xa0 控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與 CoppeliaSim 插件或 CoppeliaSim 腳本進行通信。', 'tags': '', 'url': 'Four wheel car.html'}, {'title': 'assignment 2', 'text': 'Topic 0: From Digital\xa0to Industrial + Engineering Product Design Collaboration \n Login to your gm email account and download \n DigitalProductCollaboration.pdf \n IndustrialAndEngineeringProductDesignCollaboration.pdf \n Can we create an english-english vocabulary collection service? \n https://www.autoitscript.com/forum/files/file/419-dictionary_bigdb/ \n Topic 2: Mechatronic System Design \n Login to your gm email account and download \xa0 MSModelingAndTFApproaches.pdf . \n (Can we build online tools to facilitate these processes?) \n Mechatronic Systems \n Mathematical Modeling \n Transfer Function Approaches \n Login to your gm email account and download \xa0 MechatronicDesignCases.pdf . \n DC Motor Velocity and Position Control \n Balancing Robot Control \n Magnetic Levitation System \n Topic 1: Mechanical Design Process \n Login to your gm email account and download \xa0 MechanicalDesignProcess.pdf . \n (Can we build online tools to facilitate these processes?) \n Successful Design \n Building the\xa0Design \n Structural Considerations \n Materials and\xa0Processes \n Topic 3: Mechatronic Future and Challenges \n Login to your gm email account and download \xa0 MechaFutureAndChallenges.pdf . \n Mechatronic Futures \n Mechatronics Disrupted \n Challenges in Mechatronics \n Login to your gm email account and download \xa0 MechaEducFutureNeed.pdf . \n Education to meet future need \n', 'tags': '', 'url': 'assignment 2.html'}, {'title': 'IndustrialAndEngineeringProductDesignCollaboration', 'text': "翻譯文件擷取: \n IndustrialAndEngineeringProductDesignCollaboration.pdf \n 協同產品設計過程 \xa0 \n 本研究旨在闡明工業設計師和工程設計師如何協作 \xa0 \n 這種聯盟如何反映設計過程。我們與來自六個消費產品製造商的34名工業和工程設計師進行了有關實際產品設計項目的深入採訪。 \xa0 \n 首先 從訪問數據中識別出各個設計過程。 其次 ，我們然後使用鑲嵌方法將設計過程進行比較並合併為協作過程。 最後 ，我們簡化了協作流程，以創建具有代表性的流程模型。 \xa0 \n 結果 ，我們發現了 四種類型 的典型協同產品設計流程及其特徵： \xa0 \xa0 \n E類型1 ：由ID主導的概念驅動過程， 類型2 ：由ID主導的內外聯合過程， 類型3 ：由ED主導的內在先流程， 類型4 ： ID＆ED協同流程 。 \xa0 \n \xa0 工業和工程設計師之間 \xa0 \n 它經常被認為工程設計人員使用一個'向外接近 \xa0 電子商務 \xa0 發展從功能外觀“，而工業設計師遵循'向內方法 \xa0 E \xa0 從外觀上的功能。 \xa0 \n 基於這些概念，提出了以下 兩種設計策略 ：一種是“ 由內而外 ”的策略，定義為首先設計內部工作部件，從而限制了外部形狀，另一種是“ 由外而內 ”的策略。 \xa0 \n 這些設計策略涉及公司應在特定條件下為特定目的採取的組合設計過程。但是，從經驗證據中很少了解到這兩種策略如何在工業項目中應用。很少有嘗試從工程設計和工業設計的綜合角度來看待設計過程。 \xa0 \n \xa0 本文有兩個目標 \xa0 \n 闡明在實踐中應用的原始協作產品設計過程的形式；其次，確定在不同條件下用於不同目的的不同類型的過程。為此，我們對六家消費產品製造商的工業設計師和工程設計師進行了深入採訪。我們使用“確定了每個公司的產品設計過程鑲嵌法”，其中結合了從訪談數據中提取的各個設計過程以完成一個協作過程。結果，我們確定了 四種 典型的協作產品設計流程及其特徵。\xa0 \xa0 \n 本文包括三個部分：第一部分詳細介紹了研究方法。第二部分介紹了典型的協作產品設計過程及其特徵。最後，它總結了結果，並討論了對設計文獻的影響和貢獻。 \xa0 \n \xa0 Berends，Reymen，Stultiens和Peutz（2011） \xa0 對五家公司的設計過程進行了調查。 \xa0 Kleinsmann和Valkenburg（2003） \xa0 收集了有關工業中協同設計過程的故事，並確定了協同設計項目的關鍵主題和情節。 \xa0 \xa0 \n 追溯性賬目的不可靠或不准確 （ Ackroyd＆Hughes，1981年 ） \xa0 \n 我們採用了三個標準來選擇研究目標：（1）多家公司類似的產品領域； （2）工程和工業設計部門的多個參與者； （3）在整個產品開發週期中已經完成的項目。 \xa0 \n 大多數產品開發活動需要一組輸入 \xa0 \n 基於階段的模型由旨在執行任務的動作和旨在評估執行任務的結果的決策組成；其中完成構成進展到下一個階段 \xa0 \n 初步輸出 ，狀態報告等進行生產（ Browning等人，2006年 ）。這一觀點得到了有關設計過程和組織的大量文獻的支持（例如， \xa0 Burns＆Stalker，1961； Clark，1991； Hubka＆Eder，2012 ）。 \xa0 Ulrich和Eppinger（2012） \xa0 將其描述為最終結果所必需的信息，該信息被注入以將當前設計問題轉換為下一個問題以降低不確定性，從而產生輸出，直到形成最終結果為止。這被建模為將功能規範（輸入）轉換為偽影規範（輸出）的過程。指出，從信息處理的角度進行過程建模無法捕獲完整的信息流，因為人們對交互的了解。他們認為，確定組織單位之間的相互作用的重要性，因為它們會引起建立可交付的流程模式的活動之間的依賴。決定性，過程建模的在此透視基本元件被概括為）'的信息流與IPO（輸入端 E 方法 e 輸出）REP-resentation和'相互作用組織單位的'（人，團隊，公司等“。\xa0 \xa0 \n 從狀態轉換的角度來看， \xa0 Reymen（2001） \xa0 將設計過程描述為通過在每個階段執行任務並評估設計活動將狀態從一種狀態轉移到另一種狀態的過程。這是台門車型，在設計活動發生在舞台的每一個階段，設計輸出的設計審查，從而作出決定之間是否進入下一個階段，重複當前階段或拒絕該項目的進行評估一致 ，大多數基於階段的模型都提出了這種觀點（ Wynn＆Clarkson，2005 ）。基於階段的模型由旨在執行任務的動作和旨在評估執行任務的結果的決策組成；其中完成構成進展到下一個階段 \xa0 （j̈ansch＆Birkhofer， 2006; Roozenburg ＆交叉 ，1991）。 除此之外，當從一個階段跳到另一個階段或在子過程之間鏈接時，伴隨輸入和輸出的信息流就會發生 \xa0 \n \xa0 “任務” \xa0 來表示項目的初始起點，不同於在每個階段執行的“任務”。但是，這兩個術語的用法類似，用以表示執行設計工作，因此，人們對相互連接和處理任務的設計過程達成了普遍共識（ Dorst，2008年 ）。\xa0 \xa0 \n 從狀態轉換的角度來看，有兩個活動：執行任務和評估結果。通常，評估會在相對較短的時間內進行，以決定“前進，重複或下降”。因此，我們將這些類型的活動（評估，設計審查，檢查，決策）稱為“事件”。目前，我們有兩個編碼類別： “任務”和“事件”。總之，我們可以用四個編碼類別對設計過程進行建模。 \xa0 “任務”，“事件”，“信息流”和“交互” ，並且可以用階段的連接來表示。此時，的設計過程的一個階段可以用來表示'輸入端 E 任務（設計活性 ）E 事件（deci-錫永製作） 在線 輸出“。以下描述瞭如何使用以上四種編碼類別對過程元素進行編碼。\xa0 \xa0 \n \xa0 任務 ：清除設計人員執行的任務，例如“想法草圖”，“ 3D建模”等。 “是的，我做的草圖用圓珠筆來表達我的想法。對其進行少量著色或對其進行掃描以在Photoshop上進行修飾。'我們將其編碼為帶有“想法草圖”標籤的任務類別。 事件：完成特定任務後，將進行一個事件（決策），從而導致下一個動作。一位受訪者說； '我們去樣機公司製造原型，並帶走所有兩個或三個原型。與他們舉行了一次模擬評估會議。工程師們聽老闆的批評。老闆說就是這樣，那就是，如果工程師有不同的想法，他們會提供意見。最後一個被選中。 我們在事件類別中使用標籤“模擬評估會議”對此進行了編碼。\xa0 \xa0 \n 信息流 ：當任務或事件發生時會生成信息流。它總是伴隨著輸入和輸出。一位受訪者說；實際上，我們根據工程設計人員提供的規范進行工作。直到有事情出現，我們才開始工作。這說明工業設計師從工程設計師那裡接收到了“規格數據”作為輸入，他們開始使用他們的工作。我們將此“規範數據從ED編碼為ID”。另一個摘錄是：選擇一個後，我們會將模型的3D數據傳遞到工程部門。我們發送“ STEP”文件，然後使用“ UG”開始設計。這說明他們將3D CAD數據作為設計活動的輸出發送給了工程設計人員，這些輸入成為了後續工程設計活動的輸入。我們對“從ID到ED的3D CAD數據”進行了編碼。 \xa0 交互 ：發生任務或事件時，兩組經常交互。例如，當工業設計師檢查是否可以修改內部空間時，工程設計師通過提供相關信息為他們提供建議。在這種情況下，會發生激烈的互動，工程設計師將充當“顧問”。情況就是這樣； “他們解釋說”這應該放在這裡和應擺在那裡“。然後，我們修改尺寸和位置，然後再次詢問它們是否可以減小2毫米的間隙。如果他們說“是”，我們會將一個部分壓平。我們將其編碼為“ ED到ID的顧問角色”。 \xa0 \n 我們從每個轉錄的訪談數據中識別出流程要素。我們盡可能用參與者自己的單詞標記它們。我們將現場說明用作補充數據源。在此過程中，我們按時間順序排列並連接了編碼元素，以構建部分設計過程。 該方法被廣泛採用以可視化工業過程模型。 \xa0 \n \xa0 輸出研究結果 \xa0 \n \n \xa0 流程塊中的流程從初始輸入開始，並在內部的各個小階段中運行。迭代或反饋可能在塊內的各個小階段之間發生。最後，他們對最終結果做出最終決定。這是一個里程碑，指示該階段將跳到下一階段。例如，在圖3的藍色方框中，此塊的主要工作是開發執行六個小階段的設計概念。當他們處於渲染階段時，如果在渲染評估事件中不滿意渲染結果，則可以返回到構思草圖階段。 \xa0 \n \xa0 \n 在最後階段，設計模型作為結果由高層管理人員確認，然後跳至“產品計劃會議”。在前一個結果進入下一個塊的輸入之後，兩個過程塊之間的過程流幾乎沒有機會被逆轉。跨團隊通常進行最終設計，並由高層經理在每個工作組中批准。回到上一個區塊意味著它無法滿足市場時間表。因此，應該由最高管理層對此事做出決定。 \xa0 \n \xa0 \n 成果輸入 \xa0 \n \xa0 \n 工業設計師的設計活動稱為“ Concept Design-I”，而工程設計師的設計活動稱為“ Concept Design-E”。 \xa0 \n 圖5是圖3的簡化版本。圖3中的彩色框使用了圖5中的相同彩色框進行了簡化。圖3中的藍色框變為“ Concept Design-I”。圖3中的“產品計劃會議”定義為“產品計劃”，並以細長的六邊形可視化。由於它是一個單獨且獨特的設計活動，因此被確定為單個階段。在紅色塊內部，有兩個並行的處理塊；右側的“ Concept Design-E”（紅色的小方框）是“主流程塊”，左側的“形狀修改”（黃色）是“對應的塊”。這兩個塊不視為單獨的階段，因為它們與紅色大塊內的起點到終點相連。這樣，兩個設計師團隊之間的互動就很強。為了區分兩個平行的塊，我們用粗實線表示主塊，並用淺實線表示相應的塊。在綠色塊中，由於所有12個流程之間的設計活動都沒有什麼區別，因此我們將詳細設計，測試和生產的兩個順序流程塊合併為一個。因此，在本研究中我們將它們視為一個階段。當綠色方框中的設計過程繼續進行時，工業設計師會根據工程設計師的要求或他們自己的設計檢查目的不時做出反應。他們通常將這些活動稱為“跟進”，與主要任務有所不同。這些活動顯然存在，但不屬於流程塊。它們是如圖3所示的離散過程元素，因此用虛線表示。為了幫助視覺理解，實心箭頭，雙向寬箭頭和單個方向寬箭頭分別表示過程流，相互交互和單向交互。 \xa0", 'tags': '', 'url': 'IndustrialAndEngineeringProductDesignCollaboration.html'}, {'title': 'assignment 3', 'text': '', 'tags': '', 'url': 'assignment 3.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.', 'tags': '', 'url': 'Develop.html'}]};